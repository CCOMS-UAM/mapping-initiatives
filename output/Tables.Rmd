---
title: |
  Mapping of initiatives that integrate european and
  international population cohorts
output:
  officedown::rdocx_document:
    base_format:     bookdown::word_document2
    reference_docx:  ../www/APA_6th_edition_template.docx
    fig_width:       6.73
    fig_asp:          .75
    number_sections: no
    tables:
      layout:        autofit
      caption:
        sep: '. '
    keep_md:         no
bibliography:        ../www/Mapping_initiatives.bib
csl:                 ../www/apa-old-doi-prefix.csl
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
# Environment setup:

gc()

# Libraries:
library(knitr)
library(tidyverse)
library(readxl)
library(vctrs)
library(gtsummary)
library(flextable)
library(ftExtra)
library(rlang)
library(countrycode)
library(english)
library(magrittr)
library(scales)

# Constants:
DOC_DIR      <- getwd()
ROOT_DIR     <- ".."
SRC_DIR      <- "src"
SRC_FILEPATH <- file.path(SRC_DIR, "<TODO: Complete when necessary>.R")

# Knitr configuration:

opts_knit$set(root.dir = ROOT_DIR) # Interferes with officedown!
opts_chunk$set(
  echo       = FALSE,
  results    = 'hide',
  message    = FALSE,
  warning    = FALSE,
  cache      = TRUE,
  autodep    = TRUE,
  dpi        = 300,
  fig.retina = 1,
  tab.topcaption = TRUE,
  dev.args   = list(png = list(type = "cairo"))
)


# Output formatting options:

theme_gtsummary_compact()
# theme_gtsummary_printer(print_engine = "flextable")

set_flextable_defaults(
  font.family = "Times New Roman",
  post_process_docx = theme_booktabs
)
```

```{r includes}
source("R/Constants.R", encoding = 'UTF-8')
source("R/Output.R", encoding = 'UTF-8')
```

```{r load-chunks, cache=FALSE}
## TODO: Evaluate if necessary
# SRC_FILEPATH %>% read_chunk()
```

```{r load-data}
# N.B.: Correspondence with the generating dataset
#   (see `notebook/Update_initiatives.Rmd`, result is stored in object
#   `mica_data_complete`) has been checked. The differences are due to trailing
#   whitespaces and end of line (\n) characters, which are trimmed off when
#   reading with `readxl::read_excel()`.

tab1_new <- read_excel(INITIATIVES_FILEPATH, sheet = UPDATED_TABLE_SHEET)

# Cast to proper vector types (easier than specifying all column types above):
tab1_new <- tab1_new |> mutate(
  across(
    methodology.moreCohortsToBeHarmonized,
    factor,
    levels = c("FALSE", "TRUE"),
    labels = c("No", "Yes")
  )
)

# Simplify variable names
tab1_new <- tab1_new |>
  rename_with(str_remove, pattern = "methodology.") |>
  rename_with(str_remove, pattern = "nb")           |>
  rename_with(tolower)

# Reorder variables (the ones to the output first, then the rest)
tab1_new <- tab1_new |> select(
  initiative,
  region_countries,
  description:participants.harmonized,
  age_range,
  harmonizedvariables,
  cohortcriteria,
  everything()
)
```

```{r country-derivate-vars}
# Create variable counts derivated from the countries variable
tab1_continents <- tab1_new                    |>
  separate_rows(countries, sep = COMMA)        |>
  select(id, countries)                        |>
  drop_na()                                    |>
  mutate(
    continent   = countries |>
      countrycode(origin = "country.name", destination = "continent")
  )                                            |>
  count(id, continent)                         |>
  complete(id, continent, fill = list(n = 0L)) |>
  mutate(bool = n |> as.logical())

# Complete missing values with available information in `region`:

## Create dataset with existing information (with missing nº of countries where
##   necessary):
suppressWarnings( # Warning when converting countries in `region` to `continent`
  tab1_missing_countries <- tab1_new              |>
    select(id, region)                            |>
    anti_join(tab1_continents, by = "id")         |>
    drop_na()                                     |>
    separate_rows(region, sep = ENUM_SEPS_REGEXP) |>
    mutate(
      region    = region |> str_replace("American?", "Americas"),
      # Correct values
      continent = region |>
        countrycode(origin = "country.name", destination = "continent"),
      n         = region    |>
        str_extract("\\d+") |>
        as.integer()        |>
        coalesce(continent |> is.na() |> if_else(NA_integer_, 1L)),
      continent = continent |> coalesce(
        region |> str_extract(
          VECTOR_CONTINENTS |> glue_collapse(sep = '|') |> enclose('(')
        )
      ),
      bool      = continent != TRUE # Turns all non-missing to `TRUE`
    )                                             |>
    select(-region)
)

## Complete non-present information with proper values, and overwrite the
##   "known missings":
tab1_missing_countries <- tab1_missing_countries             |>
  complete(id, continent, fill = list(n = 0L, bool = FALSE)) |>
  rows_update(tab1_missing_countries, by = c("id", "continent"))

tab1_continents <- tab1_continents  |>
  bind_rows(tab1_missing_countries) |>
  group_by(id)                      |>
  add_count(wt = bool, name = "n_continents")

tab1_continents_wide <- tab1_continents |>
  ungroup()                             |>
  pivot_wider(names_from = continent, values_from = n:bool)

tab1_new <- tab1_new |> left_join(tab1_continents_wide, by = "id")
```

```{r wbdi-regions}
# Create variable counts derivated from the countries variable
tab1_regions <- tab1_new                         |>
  separate_rows(countries, sep = COMMA)          |>
  select(id, countries)                          |>
  drop_na()                                      |>
  mutate(
    wbdi_region = countries |>
      countrycode(origin = "country.name", destination = "region")
  )                                              |>
  count(id, wbdi_region)                         |>
  complete(id, wbdi_region, fill = list(n = 0L)) |>
  mutate(bool = n |> as.logical())

# Complete missing values with available information in `region`:

## Create dataset with existing information (with missing nº of countries where
##   necessary):
suppressWarnings( # Warning when converting countries in `region` to `continent`
  tab1_missing_countries <- tab1_new              |>
    select(id, region)                            |>
    anti_join(tab1_regions, by = "id")            |>
    drop_na()                                     |>
    separate_rows(region, sep = ENUM_SEPS_REGEXP) |>
    mutate(
      region    = region |> str_replace("American?", "Americas"),
      # Correct values
      wbdi_region = region |>
        countrycode(origin = "country.name", destination = "region"),
      n         = region    |>
        str_extract("\\d+") |>
        as.integer()        |>
        coalesce(wbdi_region |> is.na() |> if_else(NA_integer_, 1L)),
      wbdi_region = wbdi_region |> coalesce(
        region |> str_extract(
          VECTOR_REGIONS |> glue_collapse(sep = '|') |> enclose('(')
        )
      ),
      wbdi_region = (region == "Oceania") |> if_else(
        true  = "East Asia & Pacific",
        false = wbdi_region
      ),
      bool      = wbdi_region != TRUE # Turns all non-missing to `TRUE`
    )                                             |>
    select(-region)
)

## Complete non-present information with proper values, and overwrite the
##   "known missings":
tab1_missing_countries <- tab1_missing_countries |>
  drop_na(wbdi_region)                           |>
  mutate(wbdi_region = wbdi_region |> factor(levels = VECTOR_REGIONS))

tab1_missing_countries <- tab1_missing_countries               |>
  complete(id, wbdi_region, fill = list(n = 0L, bool = FALSE)) |>
  rows_update(tab1_missing_countries, by = c("id", "wbdi_region"))

tab1_regions <- tab1_regions        |>
  bind_rows(tab1_missing_countries) |>
  group_by(id)                      |>
  add_count(wt = bool, name = "n_wbdi_regions")

tab1_regions_wide <- tab1_regions |>
  ungroup()                             |>
  pivot_wider(names_from = wbdi_region, values_from = n:bool)

tab1_new <- tab1_new |> left_join(tab1_regions_wide, by = "id")
```

```{r health-topic-derivate-vars}
tab1_topics <- tab1_new                   |>
  separate_rows(healthtopic, sep = '\\|') |>
  select(id, healthtopic)

tab1_topic_headers <- tab1_topics |>
  drop_na()                       |>
  distinct(healthtopic)           |>
  transmute(
    var_name  = healthtopic,
    header      = "Topic",
    subheader = healthtopic                             |>
      str_replace(
        pattern     = "birth_infancy_childhood_health",
        replacement = "Birth, infancy & childhood health"
      )                                                 |>
      str_replace_all(pattern = '_', replacement = ' ') |>
      str_to_sentence()
  )

tab1_topics <- tab1_topics                              |>
  mutate(value = TRUE)                                  |>
  complete(id, healthtopic, fill = list(value = FALSE)) |>
  drop_na()                                             |>
  pivot_wider(names_from  = healthtopic, values_from = value)
```

```{r create-output-dataset}
# Create formatted output table for the initiatives table:
tab1_new_out <- tab1_new |> select(initiative:cohortcriteria)
```

```{r preprocess-descriptives}
# Initiatives without harmonized cohorts are assigned a "missing" value
#   to the number of harmonized variables and participants, so we can have
#   those descriptives for the actual initiatives with harmonized cohorts
tab1_new <- tab1_new |> mutate(
  across(
    c(participants.harmonized, harmonizedvariables),
    if_else, condition = cohorts.harmonized != 0, false = NA_real_
  )
)
```

```{r create-headers-labels}
# Get the names from the first two rows of the file, and create names and labels
suppressMessages( # Message when reading empty column names
  tab1_headers <- read_excel(
    INITIATIVES_FILEPATH,
    sheet = TABLE_1_SHEET,
    n_max = 1
  )                                                                          |>
    pivot_longer(everything(), names_to = "header", values_to = "subheader") |>
    mutate(
      header = header                            |>
        str_detect(AUTO_VARNAME_PREFIX_REGEXP)   |>
        if_else(header |> dplyr::lag(1), header) |>
        str_replace("harmonized", "harmonised"), # Correct errata in headers:
    )                                                                        |>
    mutate( # Edit headers to correspond to the new structure:
      header    = if_else(header == "INITIATIVE", "Initiative", header),
      header    = if_else(
        header == "Region, Country",
        true  = "Region / countries",
        false = header
      ),
      header    = if_else(header == "Main objective", "Description", header),
      header    = if_else(
        header |> str_detect("^Briefly"),
        true  = "Cohort criteria",
        false = header
      )
    )                                                                        |>
    # Delete unnecessary headers
    slice(-10)                                                               |>
    bind_rows( # Add additional labels for descriptives table
      tibble(
        header    = c(
          "Age"             |> rep(2),
          "Nº of countries",# n_countries
          "Nº of regions",  # n_continents
          "Nº of countries" |> rep(5),
          "Region"          |> rep(5)
        ),
        subheader = c(
          "Minimum", "Maximum",
          NA_character_     |> rep(2), # Total countries and continents
          VECTOR_CONTINENTS |> rep(2) # Continents (nº countries and boolean)
        )
      )
    )                                                                        |>
    add_column( # Add variable names column
      var_name = colnames(
        tab1_new |> select(-(id:region), -countries, -healthtopic)
      )
    )
)

# Add health topic variables and headers/labels
tab1_new <- tab1_new |> left_join(tab1_topics, by = "id")

tab1_headers <- tab1_headers |> bind_rows(tab1_topic_headers)

# Create labels and format subheaders:
tab1_headers <- tab1_headers |>
  unite(# TODO; Use subheaders as labels (when adding headers to the desc. tab.)
    header, subheader,
    col    = "label",
    sep    = COLON,
    remove = FALSE,
    na.rm  = TRUE
  )                          |>
  mutate( # Set duplicates for cell merging
    subheader = subheader |>
      is.na()             |>
      if_else(true = header, false = subheader)
  )

# Assign meaningful labels to columns
tab1_new <- tab1_new |> imap_dfc(# Labels to assign to the columns
  \(column, variable) {
    
    properties <- tab1_headers |> filter(var_name == variable)
    
    column %@% "header"     <- properties |> pull(header)
    column %@% "label"      <- properties |> pull(label)
    column %@% "subheader"  <- properties |> pull(subheader)
    # TODO: Substituted two previous lines by the follwing:
    # column %@% "label"  <- properties |> pull(subheader)
    
    column
  }
)
```

```{r set-flextable-wd, cache=FALSE}
# Necessary for flextable to find the csl file:
opts_knit$set(root.dir = DOC_DIR)
```

```{r initiatives-table-outputs}
initiatives_table_output <- tab1_new_out                  |>
  flextable()                                             |>
  set_header_df(
    mapping = tab1_headers |> select(-label),
    key     = "var_name"
  )                                                       |>
  merge_h(part = "header")                                |>
  merge_v(part = "header")                                |>
  colformat_md(description)                               |>
  set_table_properties(layout = "autofit")
```

```{r descriptive-table}
tab1_new_describe <- tab1_new |> select(
  -where(is.character),
  -matches("^n_[A-Z]", ignore.case = FALSE)
)

descriptives_table_output <- tab1_new_describe |> tbl_summary(
  statistic    = list(all_continuous() ~ "{median} ({min} - {max})"),
  digits       = list(all_categorical() ~ c(0, 1)),
  missing_text = "(Missing)"
  # sort = # TODO: Does not seem to work
)
```

```{r descriptive-values, cache=FALSE}
# Total nº of initiatives:
total_N_out <- descriptives_table_output |> extract2("N") |> as.english()

# Maximum number of missing values in one descriptive variable:
max_missing_out <- tab1_new_out                |>
  summarize(across(.fns = ~sum(is.na(.))/n())) |>
  pivot_longer(everything())                   |>
  filter(value == max(value))                  |>
  distinct(value)                              |>
  pull()                                       |>
  percent(accuracy = .1)

# Total nº of cohorts:
total_cohorts_range_out  <- descriptives_table_output |>
  inline_text(variable = "cohorts.total", pattern = "{min} and {max}")
total_cohorts_median_out <- descriptives_table_output |>
  inline_text(variable = "cohorts.total", pattern = "{median}")

# Harmonized cohorts:
harm_cohorts_max_out <- descriptives_table_output |>
  inline_text(variable = "cohorts.harmonized", pattern = "{max}")

# More cohorts to be harmonized:
more_cohorts_expected_out <- descriptives_table_output |>
  inline_text(variable = "morecohortstobeharmonized", pattern = "{n}")

# Harmonized variables:
harm_vars_range_out  <- descriptives_table_output |>
  inline_text(variable = "harmonizedvariables", pattern = "{min} to {max}")
harm_vars_median_out <- descriptives_table_output |>
  inline_text(variable = "harmonizedvariables", pattern = "{median}")

# Harmonized participants:
harm_participants_max_out    <- descriptives_table_output |>
  inline_text(variable = "participants.harmonized", pattern = "{max}")
harm_participants_median_out <- descriptives_table_output |>
  inline_text(variable = "participants.harmonized", pattern = "{median}")

# Particinats' ages across included cohorts:
max_age_max_out  <- descriptives_table_output |>
  inline_text(variable = "age.max", pattern = "{max}")

# Topics:
prop_Ageing_out <- descriptives_table_output |>
  inline_text(variable = "ageing", pattern = "{p}%")

# Nº of countries:
max_n_countries_out <- descriptives_table_output           |>
  inline_text(variable = "n_countries", pattern = "{max}") |>
  as.integer()                                             |>
  as.english()
min_n_countries_out <- descriptives_table_output           |>
  inline_text(variable = "n_countries", pattern = "{min}") |>
  as.integer()                                             |>
  as.english()

# Nº of continents
prop_1_continent_out  <- descriptives_table_output |>
  inline_text(variable = "n_continents", level = "1", pattern = "{p}%")
prop_5_continents_out <- descriptives_table_output |>
  inline_text(variable = "n_continents", level = "5", pattern = "{p}%")

# Nº of initiatives per region
prop_Europe_out <- descriptives_table_output |>
  inline_text(variable = "bool_Europe", pattern = "{p}%")

n_Africa_out    <- descriptives_table_output             |>
  inline_text(variable = "bool_Africa", pattern = "{n}") |>
  as.integer()                                           |>
  as.english()
prop_Africa_out <- descriptives_table_output |>
  inline_text(variable = "bool_Africa", pattern = "{p}%")
```

<!-- A total of `r total_N_out` initiatives that integrate population cohorts
were identified. -->

The initiatives are presented in \@ref(tab:initiatives),
along with a subset of their most representative information.
It is worth noting that in a large amount of cases the contact person was
unreachable throughout the whole mapping process,
so the proportion of missing data was as large as
`r max_missing_out` for some properties.
The complete descriptive information of each initiative can be consulted
in the repository of the SYNCHROS project (www.synchros.eu).

The number of harmonized cohorts ranged between `r total_cohorts_range_out`
(median = `r total_cohorts_median_out`).
Some initiatives had as much as `r harm_cohorts_max_out` harmonized cohorts,
while others had harmonized cohorts at all.
However, at least `r more_cohorts_expected_out` initiatives expected
to harmonize more cohorts in the future.
The harmonized cohorts had a large variability in the maximum number of
harmonized variables, ranging from `r harm_vars_range_out`
(median = `r harm_vars_median_out`).
They would comprise as much as `r harm_participants_max_out` participants,
although the median value was around `r harm_participants_median_out`.

<br>

The targeted populations ranged in age from childbirth to as much as
`r max_age_max_out` (although this probably refers to an unbounded upper limit).
Ageing was the most prevalent topic,
addressed by a `r prop_Ageing_out` of the initiatives.
The cohorts comprised as much as `r max_n_countries_out`,
although there were also initiatives with cohorts from
only `r min_n_countries_out` country.
Most of them (`r prop_1_continent_out`) were circumscribed
to just one continent,
being Europe the most frequent (`r prop_Europe_out`),
while only a `r prop_5_continents_out` comprised cohorts from all
the five continents.
Africa was the most underrepresented continent,
with only `r n_Africa_out` initiatives (`r prop_Africa_out`) including cohorts
from it.
The complete descriptive information of the initiatives can be found in
\@ref(tab:descriptives).

# References

::: {#refs}
:::

\newpage

<!---BLOCK_LANDSCAPE_START--->

# Tables

```{r initiatives, tab.id="initiatives", tab.cap="Descriptive information of the initiatives included in the mapping.", results='asis', cache=FALSE}
initiatives_table_output
```

<!---BLOCK_LANDSCAPE_STOP--->

\newpage

```{r descriptives, tab.id="descriptives", tab.cap="Descriptive statistics of the initiatives mapped.", results='asis', cache=FALSE}
descriptives_table_output
```

```{r reset-root-dir, cache=FALSE}
# Necessary for officedown to find the template file:
opts_knit$set(root.dir = ROOT_DIR)
```
