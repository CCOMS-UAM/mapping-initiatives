---
title: "Tables"
output:
  officedown::rdocx_document:
    base_format:     bookdown::word_document2
    reference_docx:  ../www/APA_6th_edition_template.docx
    fig_width:       6.73
    fig_asp:          .75
    number_sections: no
    tables:
      layout:        autofit
      caption:
        sep: '. '
    keep_md:         no
bibliography:        ../www/Mapping_initiatives.bib
csl:                 ../www/apa-old-doi-prefix.csl
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
# Environment setup:

gc()

# Libraries:
library(knitr)
library(tidyverse)
library(readxl)
library(vctrs)
library(gtsummary)
library(flextable)
library(ftExtra)
library(rlang)
library(countrycode)

# Constants:
DOC_DIR      <- getwd()
ROOT_DIR     <- ".."
SRC_DIR      <- "src"
SRC_FILEPATH <- file.path(SRC_DIR, "<TODO: Complete when necessary>.R")

# Knitr configuration:

opts_knit$set(root.dir = ROOT_DIR) # Interferes with officedown!
opts_chunk$set(
  echo       = FALSE,
  results    = 'hide',
  message    = FALSE,
  warning    = FALSE,
  cache      = TRUE,
  autodep    = TRUE,
  dpi        = 300,
  fig.retina = 1,
  tab.topcaption = TRUE,
  dev.args   = list(png = list(type = "cairo"))
)


# Output formatting options:

theme_gtsummary_compact()
# theme_gtsummary_printer(print_engine = "flextable")

set_flextable_defaults(
  font.family = "Times New Roman",
  post_process_docx = theme_box
)
```

```{r includes}
source("R/Constants.R", encoding = 'UTF-8')
source("R/Output.R", encoding = 'UTF-8')
```

```{r load-chunks, cache=FALSE}
## TODO: Evaluate if necessary
# SRC_FILEPATH %>% read_chunk()
```

```{r load-data}
# N.B.: Correspondence with the generating dataset
#   (see `notebook/Update_initiatives.Rmd`, result is stored in object
#   `mica_data_complete`) has been checked. The differences are due to trailing
#   whitespaces and end of line (\n) characters, which are trimmed off when
#   reading with `readxl::read_excel()`.

tab1_new <- read_excel(INITIATIVES_FILEPATH, sheet = UPDATED_TABLE_SHEET)

# Cast to proper vector types (easier than specifying all column types above):
tab1_new <- tab1_new |> mutate(
  across(
    methodology.moreCohortsToBeHarmonized,
    factor,
    levels = c("FALSE", "TRUE"),
    labels = c("No", "Yes")
  )
)

# Simplify variable names
tab1_new <- tab1_new |>
  rename_with(str_remove, pattern = "methodology.") |>
  rename_with(str_remove, pattern = "nb")           |>
  rename_with(tolower)

# Reorder variables (the ones to the output first, then the rest)
tab1_new <- tab1_new |> select(
  initiative,
  region_countries,
  description:participants.harmonized,
  age_range,
  harmonizedvariables,
  cohortcriteria,
  everything()
)
```

```{r country-derivate-vars}
# Create variable counts derivated from the countries variable
tab1_continents <- tab1_new                                                  |>
  separate_rows(countries, sep = COMMA)                                      |>
  select(id, countries)                                                      |>
  drop_na()                                                                  |>
  mutate(
    continent = countries |>
      countrycode(origin = "country.name", destination = "continent")
  )                                                                          |>
  count(id, continent)                                                       |>
  complete(id, continent, fill = list(n = 0L))                               |>
  mutate(bool = n |> as.logical())

# Complete missing values with available information in `region`:

## Create dataset with existing information (with missing nº of countries where
##   necessary):
suppressWarnings( # Warning when converting countries in `region` to `continent`
  tab1_missing_countries <- tab1_new              |>
    select(id, region)                            |>
    anti_join(tab1_continents, by = "id")         |>
    drop_na()                                     |>
    separate_rows(region, sep = ENUM_SEPS_REGEXP) |>
    mutate(
      region    = region |> str_replace("American?", "Americas"),
      # Correct values
      continent = region |>
        countrycode(origin = "country.name", destination = "continent"),
      n         = region    |>
        str_extract("\\d+") |>
        as.integer()        |>
        coalesce(continent |> is.na() |> if_else(NA_integer_, 1L)),
      continent = continent |> coalesce(
        region |> str_extract(
          VECTOR_CONTINENTS |> glue_collapse(sep = '|') |> enclose('(')
        )
      ),
      bool      = continent != TRUE # Turns all non-missing to `TRUE`
    )                                              |>
    select(-region)
)
  
## Complete non-present information with proper values, and overwrite the
##   "known missings":
tab1_missing_countries <- tab1_missing_countries             |>
  complete(id, continent, fill = list(n = 0L, bool = FALSE)) |>
  rows_update(tab1_missing_countries, by = c("id", "continent"))

tab1_continents      <- tab1_continents |> bind_rows(tab1_missing_countries)
tab1_continents_wide <- tab1_continents |>
  pivot_wider(names_from = continent, values_from = n:bool)

tab1_new <- tab1_new |> left_join(tab1_continents_wide, by = "id")
```

```{r create-output-dataset}
# Create formatted output table for the initiatives table:
tab1_new_out <- tab1_new |> select(initiative:cohortcriteria)
```

```{r create-headers-labels}
# Get the names from the first two rows of the file, and create names and labels
suppressMessages( # Message when reading empty column names
  tab1_headers <- read_excel(
    INITIATIVES_FILEPATH,
    sheet = TABLE_1_SHEET,
    n_max = 1
  )                                                                          |>
    pivot_longer(everything(), names_to = "header", values_to = "subheader") |>
    mutate(
      header = header                            |>
        str_detect(AUTO_VARNAME_PREFIX_REGEXP)   |>
        if_else(header |> dplyr::lag(1), header) |>
        str_replace("harmonized", "harmonised"), # Correct errata in headers:
    )                                                                        |>
    mutate( # Edit headers to correspond to the new structure:
      header    = if_else(header == "INITIATIVE", "Initiative", header),
      header    = if_else(
        header == "Region, Country",
        true  = "Region / countries",
        false = header
      ),
      header    = if_else(header == "Main objective", "Description", header),
      header    = if_else(
        header |> str_detect("^Briefly"),
        true  = "Cohort criteria",
        false = header
      )
    )                                                                        |>
    # Delete unnecessary headers
    slice(-10)                                                               |>
    bind_rows( # Add additional labels for descriptives table
      tibble(
        header    = c(
          "Age"             |> rep(2),
          "Nº of countries" |> rep(6),
          "Region"          |> rep(5)
        ),
        subheader = c(
          "Minimum", "Maximum",
          NA_character_, # Total countries
          VECTOR_CONTINENTS |> rep(2) # Continents (nº countries and boolean)
        )
      )
    )                                                                        |>
    add_column( # Add variable names column
      var_name = colnames(tab1_new |> select(-(id:region), -countries))
    )
)

tab1_headers <- tab1_headers |>
  unite(# TODO; Use subheaders as labels (when adding headers to the desc. tab.)
    header, subheader,
    col    = "label",
    sep    = COLON,
    remove = FALSE,
    na.rm  = TRUE
  )                          |>
  mutate( # Set duplicates for cell merging
    subheader = subheader |> is.na() |> if_else(true = header, false = subheader)
  )

# Assign meaningful labels to columns
tab1_new <- tab1_new |> imap_dfc(# Labels to assign to the columns
  \(column, variable) {
    
    properties <- tab1_headers |> filter(var_name == variable)
    
    column %@% "header" <- properties |> pull(header)
    column %@% "label"  <- properties |> pull(label)
    column %@% "subheader"  <- properties |> pull(subheader)
    # TODO: Substituted two previous lines by the follwing:
    # column %@% "label"  <- properties |> pull(subheader)
    
    column
  }
)
```

```{r set-flextable-wd, cache=FALSE}
# Necessary for flextable to find the csl file:
opts_knit$set(root.dir = DOC_DIR)
```

```{r initiatives-table-outputs}
initiatives_table_output <- tab1_new_out                  |>
  flextable()                                             |>
  set_header_df(mapping = tab1_headers, key = "var_name") |>
  merge_h(part = "header")                                |>
  merge_v(part = "header")                                |>
  colformat_md(description)                               |>
  set_table_properties(layout = "autofit")
```

```{r descriptive-table}
descriptives_table_output <- tab1_new          |>
  select(
    where(is.numeric),
    where(is.logical),
    -matches("^n_[A-Z]", ignore.case = FALSE)
  )                                            |>
  tbl_summary(missing_text = "(Missing)")      |>
  gtsummary::as_flex_table()
```


# References

::: {#refs}
:::

\newpage

# Tables

<!---BLOCK_LANDSCAPE_START--->

```{r initiatives, tab.id="initiatives", tab.cap="Descriptive information of the initiatives included in the mapping.", results='asis', cache=FALSE}
# initiatives_table_output
```

<!---BLOCK_LANDSCAPE_STOP--->

\newpage

```{r descriptives, tab.id="descriptives", tab.cap="Descriptive statistics of the initiatives mapped.", results='asis', cache=FALSE}
# descriptives_table_output
```

```{r reset-root-dir, cache=FALSE}
# Necessary for officedown to find the template file:
opts_knit$set(root.dir = ROOT_DIR)
```
